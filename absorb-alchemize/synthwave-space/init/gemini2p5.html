<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Synthwave Void Striker</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            display: block;
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff;
        }
        #score {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 2em;
            color: #00ffff;
        }
        #game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            text-align: center;
            flex-direction: column;
            pointer-events: all;
        }
        #game-over-overlay h1 {
            font-size: 4em;
            margin: 0;
            color: #ff007f;
            text-shadow: 0 0 15px #ff007f, 0 0 30px #ff007f;
        }
        #final-score {
            font-size: 2em;
            margin: 20px 0;
            color: #00ffff;
        }
        #restart-button {
            padding: 15px 30px;
            font-size: 1.5em;
            background-color: transparent;
            border: 2px solid #00ffff;
            color: #00ffff;
            cursor: pointer;
            text-shadow: 0 0 10px #00ffff;
            transition: all 0.3s ease;
        }
        #restart-button:hover {
            background-color: #00ffff;
            color: #000;
            box-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
        }
        #joystick-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            display: none; /* Hidden by default */
            pointer-events: all;
        }
        #joystick-base {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border: 2px solid rgba(0, 255, 255, 0.5);
        }
        #joystick-knob {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <div id="score">SCORE: 0</div>
        <div id="game-over-overlay">
            <h1>GAME OVER</h1>
            <div id="final-score"></div>
            <button id="restart-button">RESTART</button>
        </div>
    </div>
    
    <div id="joystick-container">
        <div id="joystick-base"></div>
        <div id="joystick-knob"></div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- GAME STATE & CONSTANTS ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        let score = 0;
        let isGameOver = true;
        
        const PLAYER_SPEED = 0.2;
        const LASER_SPEED = 1.5;
        const ENEMY_SPEED = 0.05;
        const ENEMY_SPAWN_RATE = 1000; // ms
        let lastEnemySpawn = 0;
        
        const keys = {};
        const isTouchDevice = 'ontouchstart' in window;
        
        let isPaused = false;
        window.addEventListener('message', (e) => {
             if (e.data && e.data.type === 'PAUSE_GAME') {
                 isPaused = e.data.payload;
                 if (!isPaused) clock.getDelta();
             }
        });

        // --- SCENE SETUP ---
        function setupScene() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            scene.fog = new THREE.FogExp2(0x000000, 0.015);
            camera.position.z = 15;
            camera.position.y = 3;
            camera.lookAt(0,0,0);
        }
        
        // --- POST-PROCESSING (BLOOM) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2;
        bloomPass.strength = 1.8;
        bloomPass.radius = 0.55;
        
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- SHADER-BASED STARFIELD BACKGROUND ---
        const starfieldMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 1.0 },
                resolution: { value: new THREE.Vector2() }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec2 vUv;

                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
                }

                float star(vec2 uv, float flare) {
                    float d = length(uv);
                    float m = 0.05 / d;
                    
                    float rays = max(0.0, 1.0 - abs(uv.x * uv.y * 1000.0));
                    m += rays * flare;
                    
                    if (d > 0.2) m = 0.0;
                    return m;
                }

                void main() {
                    vec2 uv = (vUv - 0.5) * 2.0;
                    uv.x *= 1.0; 
                    
                    vec3 col = vec3(0.0);
                    
                    // Layer 1: Distant stars
                    vec2 grid = fract(uv * 50.0) - 0.5;
                    float star_d = length(grid);
                    float star_t = 0.005 / star_d;
                    col += vec3(star_t) * 0.8;

                    // Layer 2: Moving nebulas
                    vec2 uv_nebula = vUv;
                    uv_nebula.y += time * 0.01;
                    float nebula1 = sin(uv_nebula.y * 5.0 + time * 0.1) * 0.5 + 0.5;
                    float nebula2 = cos(uv_nebula.x * 3.0 - time * 0.05) * 0.5 + 0.5;
                    col += vec3(0.8 * nebula1, 0.2 * nebula2, 0.9 * nebula1 * nebula2) * 0.15;
                    
                    // Layer 3: Closer, brighter stars
                    for(int i = 0; i < 50; i++) {
                        float fi = float(i);
                        vec2 star_uv = uv;
                        star_uv.x += random(vec2(fi, fi)) * 2.0 - 1.0;
                        star_uv.y += random(vec2(fi, fi+1.0)) * 2.0 - 1.0;
                        star_uv.x += sin(time*0.1+fi)*0.1;
                        star_uv.y += cos(time*0.1+fi)*0.1;
                        
                        col += vec3(star(star_uv, 0.5)) * vec3(random(vec2(fi,0.0)), random(vec2(fi,1.0)), 1.0) * 0.5;
                    }
                    
                    gl_FragColor = vec4(col, 1.0);
                }
            `,
            side: THREE.BackSide
        });

        const starfield = new THREE.Mesh(
            new THREE.SphereGeometry(500, 64, 64),
            starfieldMaterial
        );
        scene.add(starfield);

        // --- PLAYER SPACESHIP ---
        class Player {
            constructor() {
                const group = new THREE.Group();

                const bodyMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
                const wingMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true });

                const bodyGeom = new THREE.ConeGeometry(0.8, 2.5, 6);
                const body = new THREE.Mesh(bodyGeom, bodyMat);
                body.rotation.x = Math.PI / 2;
                group.add(body);
                
                const cockpitGeom = new THREE.IcosahedronGeometry(0.4, 0);
                const cockpit = new THREE.Mesh(cockpitGeom, wingMat);
                cockpit.position.z = 0.5;
                group.add(cockpit);

                const wingShape = new THREE.Shape();
                wingShape.moveTo(0, 0.5);
                wingShape.lineTo(2, 0);
                wingShape.lineTo(2, -0.2);
                wingShape.lineTo(0, 0.2);
                wingShape.lineTo(0, 0.5);
                const wingGeom = new THREE.ExtrudeGeometry(wingShape, { depth: 0.1, bevelEnabled: false });
                
                const leftWing = new THREE.Mesh(wingGeom, wingMat);
                leftWing.position.set(0.5, 0, -0.2);
                group.add(leftWing);
                
                const rightWing = leftWing.clone();
                rightWing.rotation.y = Math.PI;
                rightWing.position.x = -0.5;
                group.add(rightWing);
                
                this.mesh = group;
                this.mesh.scale.set(0.7, 0.7, 0.7);
                this.targetPosition = new THREE.Vector3();
                this.boundingBox = new THREE.Box3();
                scene.add(this.mesh);
            }
            
            update() {
                // Smooth lerp movement
                this.mesh.position.lerp(this.targetPosition, 0.1);
                
                // Bank the ship based on horizontal movement
                const velocityX = this.targetPosition.x - this.mesh.position.x;
                this.mesh.rotation.z = -velocityX * 1.5;
                this.mesh.rotation.y = -velocityX * 0.5;
                
                this.boundingBox.setFromObject(this.mesh);
            }
            
            reset() {
                this.mesh.position.set(0, 0, 0);
                this.targetPosition.set(0, 0, 0);
            }
        }
        const player = new Player();
        
        // --- OBJECT POOLING ---
        class ObjectPool {
            constructor(objectClass, initialSize) {
                this.pool = [];
                this.active = [];
                for (let i = 0; i < initialSize; i++) {
                    const obj = new objectClass();
                    scene.remove(obj.mesh);
                    this.pool.push(obj);
                }
            }
            
            get() {
                let obj;
                if (this.pool.length > 0) {
                    obj = this.pool.pop();
                } else {
                    // Pool is empty, create a new object if needed (fallback)
                    obj = new this.pool[0].constructor();
                }
                
                scene.add(obj.mesh);
                this.active.push(obj);
                return obj;
            }
            
            release(obj) {
                const index = this.active.indexOf(obj);
                if (index > -1) {
                    this.active.splice(index, 1);
                    scene.remove(obj.mesh);
                    this.pool.push(obj);
                }
            }
            
            update(...args) {
                for (let i = this.active.length - 1; i >= 0; i--) {
                    if (!this.active[i].update(...args)) {
                        this.release(this.active[i]);
                    }
                }
            }
            
            clearAll() {
                 for (let i = this.active.length - 1; i >= 0; i--) {
                    this.release(this.active[i]);
                }
            }
        }
        
        // --- LASER ---
        class Laser {
            constructor() {
                const material = new THREE.LineBasicMaterial({ color: 0x00ffff });
                const points = [new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -2)];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                this.mesh = new THREE.Line(geometry, material);
                this.boundingBox = new THREE.Box3();
            }

            fire(position) {
                this.mesh.position.copy(position);
                this.mesh.position.z -= 1.5;
            }

            update() {
                this.mesh.position.z -= LASER_SPEED;
                this.boundingBox.setFromObject(this.mesh);
                return this.mesh.position.z > -200; // Return false to be released from pool
            }
        }
        const laserPool = new ObjectPool(Laser, 20);

        // --- ENEMY ---
        class Enemy {
            constructor() {
                const geometries = [
                    new THREE.BoxGeometry(2, 2, 2),
                    new THREE.IcosahedronGeometry(1.2, 0),
                    new THREE.OctahedronGeometry(1.5, 0)
                ];
                const geometry = geometries[Math.floor(Math.random() * geometries.length)];
                const material = new THREE.MeshBasicMaterial({ color: 0xff007f, wireframe: true });
                this.mesh = new THREE.Mesh(geometry, material);
                this.boundingBox = new THREE.Box3();
            }

            spawn() {
                const side = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
                const xRange = window.innerWidth / window.innerHeight * 15;
                const yRange = 15;

                switch (side) {
                    case 0: // Top
                        this.mesh.position.set(THREE.MathUtils.randFloat(-xRange, xRange), yRange, -200);
                        break;
                    case 1: // Right
                        this.mesh.position.set(xRange, THREE.MathUtils.randFloat(-yRange, yRange), -200);
                        break;
                    case 2: // Bottom
                        this.mesh.position.set(THREE.MathUtils.randFloat(-xRange, xRange), -yRange, -200);
                        break;
                    case 3: // Left
                        this.mesh.position.set(-xRange, THREE.MathUtils.randFloat(-yRange, yRange), -200);
                        break;
                }
                this.mesh.lookAt(player.mesh.position);
            }
            
            update() {
                this.mesh.position.z += ENEMY_SPEED * 10;
                this.mesh.rotation.x += 0.01;
                this.mesh.rotation.y += 0.01;
                this.boundingBox.setFromObject(this.mesh);
                
                // Collision with player
                if (!isGameOver && this.boundingBox.intersectsBox(player.boundingBox)) {
                    gameOver();
                }
                
                return this.mesh.position.z < camera.position.z;
            }
        }
        const enemyPool = new ObjectPool(Enemy, 30);

        // --- PARTICLE EXPLOSION ---
        class Particle {
            constructor() {
                const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                const material = new THREE.MeshBasicMaterial({ color: 0xff00ff });
                this.mesh = new THREE.Mesh(geometry, material);
                this.life = 0;
                this.maxLife = 100;
                this.velocity = new THREE.Vector3();
            }
            
            activate(position, color) {
                this.mesh.position.copy(position);
                this.mesh.material.color.set(color);
                this.velocity.set(
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5
                );
                this.life = this.maxLife;
            }
            
            update() {
                this.life--;
                this.mesh.position.add(this.velocity);
                const scale = this.life / this.maxLife;
                this.mesh.scale.set(scale, scale, scale);
                this.velocity.multiplyScalar(0.98); // friction
                return this.life > 0;
            }
        }
        const particlePool = new ObjectPool(Particle, 200);

        function createExplosion(position, color, count) {
            for (let i = 0; i < count; i++) {
                const particle = particlePool.get();
                if (particle) {
                    particle.activate(position, color);
                }
            }
        }
        
        // --- GAME LOGIC ---
        function startGame() {
            score = 0;
            isGameOver = false;
            
            player.reset();
            enemyPool.clearAll();
            laserPool.clearAll();
            particlePool.clearAll();

            document.getElementById('game-over-overlay').style.display = 'none';
            document.getElementById('score').textContent = 'SCORE: 0';
            
            lastEnemySpawn = performance.now();
            animate();
        }
        
        function gameOver() {
            isGameOver = true;
            createExplosion(player.mesh.position, 0x00ffff, 100);
            
            const overlay = document.getElementById('game-over-overlay');
            document.getElementById('final-score').textContent = `FINAL SCORE: ${score}`;
            overlay.style.display = 'flex';
        }
        
        function checkCollisions() {
            laserPool.active.forEach(laser => {
                enemyPool.active.forEach(enemy => {
                    if (laser.boundingBox.intersectsBox(enemy.boundingBox)) {
                        createExplosion(enemy.mesh.position, 0xff007f, 50);
                        enemyPool.release(enemy);
                        laserPool.release(laser);
                        score += 100;
                        document.getElementById('score').textContent = `SCORE: ${score}`;
                    }
                });
            });
        }
        
        // --- CONTROLS ---
        function setupControls() {
            // Desktop
            window.addEventListener('keydown', e => keys[e.code] = true);
            window.addEventListener('keyup', e => keys[e.code] = false);
            
            // Mobile
            if (isTouchDevice) {
                document.getElementById('joystick-container').style.display = 'block';
                setupJoystick();
                
                window.addEventListener('touchstart', (e) => {
                    if (isGameOver) return;
                    // Fire if touching the right half of the screen
                    if (e.touches[0].clientX > window.innerWidth / 2) {
                        const laser = laserPool.get();
                        if(laser) laser.fire(player.mesh.position);
                    }
                }, { passive: false });
            }
        }
        
        function updatePlayerPosition() {
            const moveSpeed = PLAYER_SPEED;
            if (keys['ArrowUp'] || keys['KeyW']) player.targetPosition.y += moveSpeed;
            if (keys['ArrowDown'] || keys['KeyS']) player.targetPosition.y -= moveSpeed;
            if (keys['ArrowLeft'] || keys['KeyA']) player.targetPosition.x -= moveSpeed;
            if (keys['ArrowRight'] || keys['KeyD']) player.targetPosition.x += moveSpeed;
            
            // Firing
            if (keys['Space']) {
                const laser = laserPool.get();
                if(laser) laser.fire(player.mesh.position);
                keys['Space'] = false; // Prevent holding down space
            }
            
            // Clamp position
            const xLimit = (window.innerWidth / window.innerHeight) * 8;
            const yLimit = 8;
            player.targetPosition.x = Math.max(-xLimit, Math.min(xLimit, player.targetPosition.x));
            player.targetPosition.y = Math.max(-yLimit, Math.min(yLimit, player.targetPosition.y));
        }

        function setupJoystick() {
            const container = document.getElementById('joystick-container');
            const knob = document.getElementById('joystick-knob');
            const baseRect = container.getBoundingClientRect();
            const center = { x: baseRect.width / 2, y: baseRect.height / 2 };
            const maxRadius = baseRect.width / 2 - knob.offsetWidth / 2;
            let activeTouchId = null;

            container.addEventListener('touchstart', (e) => {
                e.preventDefault();
                activeTouchId = e.changedTouches[0].identifier;
            }, { passive: false });

            container.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (activeTouchId === null) return;
                
                let touch;
                for(let i=0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === activeTouchId) {
                        touch = e.changedTouches[i];
                        break;
                    }
                }
                if (!touch) return;
                
                const move = {
                    x: touch.clientX - baseRect.left - center.x,
                    y: touch.clientY - baseRect.top - center.y
                };
                
                const dist = Math.min(maxRadius, Math.hypot(move.x, move.y));
                const angle = Math.atan2(move.y, move.x);

                knob.style.transform = `translate(-50%, -50%) translate(${Math.cos(angle) * dist}px, ${Math.sin(angle) * dist}px)`;
                
                player.targetPosition.x += (Math.cos(angle) * dist / maxRadius) * PLAYER_SPEED;
                player.targetPosition.y -= (Math.sin(angle) * dist / maxRadius) * PLAYER_SPEED;

            }, { passive: false });

            const endTouch = () => {
                activeTouchId = null;
                knob.style.transform = 'translate(-50%, -50%)';
            };
            container.addEventListener('touchend', endTouch);
            container.addEventListener('touchcancel', endTouch);
        }

        // --- RESIZE HANDLER ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        }
        window.addEventListener('resize', onWindowResize);
        
        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();
        function animate() {
            if (isGameOver) return;
            
            requestAnimationFrame(animate);
            
            if (isPaused) return;

            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();
            
            // Update shader uniforms
            starfieldMaterial.uniforms.time.value = elapsedTime;
            
            // Update game objects
            updatePlayerPosition();
            player.update();
            laserPool.update();
            enemyPool.update();
            particlePool.update();
            
            // Spawn enemies
            if (performance.now() - lastEnemySpawn > ENEMY_SPAWN_RATE) {
                const enemy = enemyPool.get();
                if (enemy) enemy.spawn();
                lastEnemySpawn = performance.now();
            }
            
            checkCollisions();

            composer.render(delta);
        }
        
        // --- INITIALIZATION ---
        setupScene();
        setupControls();
        document.getElementById('restart-button').addEventListener('click', startGame);
        
        // Show initial start screen
        const overlay = document.getElementById('game-over-overlay');
        overlay.querySelector('h1').textContent = 'VOID STRIKER';
        overlay.querySelector('#final-score').textContent = isTouchDevice ? 
            'Use left joystick to move. Tap right to fire.' : 
            'Use WASD/Arrows to move. Press Space to fire.';
        overlay.querySelector('#restart-button').textContent = 'START';
        overlay.style.display = 'flex';
    </script>
</body>
</html>